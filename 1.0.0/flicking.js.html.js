tui.util.defineNamespace("fedoc.content", {});
fedoc.content["flicking.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview The flicking component that support swipe user interaction on web browser.\n * @author NHN Ent. FE dev team &lt;dl_javascript@nhnent.com>\n */\n\n/**\n * @constructor\n * @example\n * var flick = new tui.component.m.Flicking({\n *    element: document.getElementById('flick'), // element(mask element)\n *    wrapper: document.getElementById('flick-wrap1'), // warpper\n *    flow: 'horizontal', // direction ('horizontal|vertical)\n *    isMagnetic: true, // use magnetic\n *    isCircular: true, // circular\n *    isFixedHTML: false, // fixed HTML\n *    itemClass: 'item', // item(panel) class\n *    data: '&lt;strong style=\"color:white;display:block;text-align:center;margin-top:100px\">item&lt;/strong>', // item innerHTML\n *    select: 1, // select\n *    flickRange: 100, // flickRange(Criteria to cognize)\n *    effect: 'linear', // effect(default linear)\n *    duration: 300 // animation duration\n * });\n *\n */\nvar Flicking = tui.util.defineClass(/** @lends Flicking.prototype */{\n    /**\n     * whether magnetic use(Defalut true)\n     * @type {boolean}\n     */\n    isMagnetic: true,\n    /**\n     * Template of panel item\n     */\n    template: '&lt;div>{{data}}&lt;/div>',\n    /**\n     * A class name of flicking panel item\n     */\n    itemClass: 'panel',\n    /**\n     * Flicking panel item html tag\n     */\n    itemTag: 'div',\n    /**\n     * The flow of flicking(horizontal|vertical)\n     */\n    flow: 'horizontal',\n    /**\n     * The roop flicking\n     */\n    isCircular: true,\n    /**\n     * Whether model use or not\n     */\n    isFixedHTML: true,\n    /**\n     * The distance that to be determined to flicking.\n     */\n    flickRange: 50,\n    /**\n     * A effect of flicking\n     */\n    effect: 'linear',\n    /**\n     * A duration of flicking\n     */\n    duration: 100,\n\n    /*************\n     * initialize methods\n     *************/\n    init: function(option) {\n        // options\n        this.element = option.element;\n        this.wrapper = option.wrapper;\n        this.itemTag = option.itemTag || this.itemTag;\n        this.itemClass = option.itemClass || this.itemClass;\n        this.template = option.template || this.template;\n        this.flow = option.flow || this.flow;\n        this.isMagnetic = tui.util.isExisty(option.isMagnetic) ? option.isMagnetic : this.isMagnetic;\n        this.isCircular = tui.util.isExisty(option.isCircular) ? option.isCircular : this.isCircular;\n        this.isFixedHTML = tui.util.isExisty(option.isFixedHTML) ? option.isFixedHTML : this.isFixedHTML;\n        this.effect = option.effect || this.effect;\n        this.flickRange = option.flickRange || this.flickRange;\n        this.duration = option.duration || this.duration;\n\n        // to figure position to move\n        this.startPos = {};\n        this.savePos = {};\n\n        // data is set by direction or flow\n        this._setConfig();\n\n        if (!this.isFixedHTML) {\n            this._makeItems(option.data || '');\n        }\n\n        // init helper for MoveAnimator, movedetector\n        this._initHelpers();\n        this._initElements();\n        this._initWrap();\n        this._attachEvent();\n    },\n\n    /**\n     * Set configurations\n     * @private\n     */\n    _setConfig: function() {\n        var isVertical = (this.flow === 'vertical');\n        if (isVertical) {\n            this._config = {\n                direction: ['N','S'],\n                way: 'top',\n                dimension: 'height',\n                point: 'y',\n                width: this.element.clientHeight\n            };\n        } else {\n            this._config = {\n                direction: ['W','E'],\n                way: 'left',\n                dimension: 'width',\n                point: 'x',\n                width: this.element.clientWidth\n            };\n        }\n    },\n\n    /**\n     * Initialize method for helper objects\n     * @private\n     */\n    _initHelpers: function() {\n        // MoveAnimator component\n        this.mover = new tui.component.Effects.Slide({\n            flow: this.flow,\n            element: this.wrapper,\n            effect: this.effect,\n            duration: this.duration\n        });\n        // MoveDetector component\n        this.movedetect = new tui.component.Gesture.Reader({\n            flickRange: this.flickRange,\n            type: 'flick'\n        });\n    },\n\n    /**\n     * Initialize wrapper element.\n     * @private\n     */\n    _initWrap: function() {\n        var config = this._config;\n        this.wrapper.style[config.way] = '0px';\n        this.wrapper.style[config.dimension] = config.width * this.elementCount + 'px';\n    },\n\n    /**\n     * Initialize panel item element\n     * @private\n     */\n    _initElements: function() {\n        this.elementCount = 0;\n        tui.util.forEachArray(this.wrapper.children, function(element) {\n            if (element.nodeType === 1) {\n                element.style.width = this._config.width + 'px';\n                this.elementCount += 1;\n            }\n        }, this);\n    },\n\n    /**\n     * Attach event handler\n     * @private\n     */\n    _attachEvent: function() {\n        this.onTouchMove = tui.util.bind(this._onTouchMove, this);\n        this.onTouchEnd = tui.util.bind(this._onTouchEnd, this);\n        this.element.addEventListener('touchstart', tui.util.bind(this.onTouchStart, this));\n    },\n\n    /**\n     * Create elements, if panel html is not fixed.\n     * @param {object} data 입력된 데이터 정보\n     * @private\n     */\n    _makeItems: function(data) {\n        var item = this._getElement(data);\n        this.wrapper.appendChild(item);\n    },\n\n    /**\n     * Make element and return\n     * @param {object} data html 데이터\n     * @returns {Element}\n     * @private\n     */\n    _getElement: function(data) {\n        var item = document.createElement(this.itemTag);\n        item.className = this.itemClass;\n        item.innerHTML = data;\n        item.style[this._config.dimension] = this._config.width + 'px';\n        return item;\n    },\n\n    /*************\n     * event handle methods\n     *************/\n\n    /**\n     * Handle to touch start event\n     * @param {object} e touchstart event\n     */\n    onTouchStart: function(e) {\n        if (this.isLocked) {\n            return;\n        }\n\n        /**\n         * @api\n         * @event Flicking#beforeMove\n         * @type {Flicking}\n         * @example\n         * flick.on('beforeMove', function() {\n         *     var left = getData('left');\n         *     var right = getData('right');\n         *     flick.setPrev(left);\n         *     flick.setNext(right);\n         *     document.getElementById('move').innerHTML = 'beforeMove';\n         * });\n         */\n        this.fire('beforeMove', this);\n\n        if (this.isFixedHTML &amp;&amp; this.isCircular) {\n            this._prepareMoveElement();\n        }\n\n        // save touchstart data\n        this._saveTouchStartData(e.touches[0]);\n\n        document.addEventListener('touchmove', this.onTouchMove);\n        document.addEventListener('touchend', this.onTouchEnd);\n    },\n\n    /**\n     * Handle to touch move event\n     * @param {event} e touchmove event\n     * @private\n     */\n    _onTouchMove: function(e) {\n        var pos = this.startPos,\n            movement,\n            start,\n            end;\n\n        e.preventDefault();\n        this.savePos.x = e.touches[0].clientX;\n        this.savePos.y = e.touches[0].clientY;\n\n        if (this.flow === 'horizontal') {\n            start = pos.x;\n            end = this.savePos.x;\n        } else {\n            start = pos.y;\n            end = this.savePos.y;\n        }\n\n        movement = end - start;\n        this.wrapper.style[this._config.way] = pos[this._config.way] + movement + 'px';\n    },\n\n    /**\n     * Handle to touch end event\n     * @private\n     */\n    _onTouchEnd: function() {\n        var point = this._config.point;\n        if (this.startPos[point] === this.savePos[point]) {\n            this._resetMoveElement();\n        } else if (this.isMagnetic) {\n            this._activeMagnetic();\n        }\n\n        document.removeEventListener('touchMove', this.onTouchMove);\n        document.removeEventListener('touchEnd', this.onTouchEnd);\n    },\n\n    /**\n     * Save touch position\n     * @param {object} point 터치 이벤트 좌표\n     * @private\n     */\n    _saveTouchStartData: function(point) {\n        this.startPos[this._config.way] = this._getElementPos();\n        this.savePos.x = this.startPos.x = point.clientX;\n        this.savePos.y = this.startPos.y = point.clientY;\n        this.startPos.time = (new Date()).getTime();\n    },\n\n    /*************\n     * methods to edit move elements\n     *************/\n\n    /**\n     * Prepare elements for moving\n     * @private\n     */\n    _prepareMoveElement: function() {\n        this._setClone();\n        this._setPrev();\n        this._setNext();\n    },\n\n    /**\n     * Reset elements for moving\n     * @private\n     */\n    _resetMoveElement: function() {\n        var none = 'none';\n        if (!this.isFixedHTML) {\n            this._removePadding({ way: none });\n        } else {\n            if (this.isCircular) {\n                this._removeClones({ way: none });\n            }\n        }\n    },\n\n    /**\n     * Active magnetic to fix position wrapper and clones\n     * @private\n     */\n    _activeMagnetic: function() {\n        this._fixInto({\n            x: this.savePos.x,\n            y: this.savePos.y,\n            start: this.startPos.time,\n            end: (new Date()).getTime()\n        });\n    },\n\n    /**\n     * Set prev panel\n     * @api\n     * @param {string} data A data of flicking\n     */\n    setPrev: function(data) {\n        var config = this._config;\n        var element = this._getElement(data);\n        this.expandMovePanel();\n        this.wrapper.style[config.way] = this._getElementPos() - config.width + 'px';\n        this.wrapper.insertBefore(element, this.wrapper.firstChild);\n    },\n\n    /**\n     * Set next panel\n     * @api\n     * @param {string} data  A data of flicking\n     */\n    setNext: function(data) {\n        var element = this._getElement(data);\n        this.expandMovePanel();\n        this.wrapper.appendChild(element);\n    },\n\n    /**\n     * Set clone elements\n     * @private\n     */\n    _setClone: function() {\n        var count = 0;\n        this.clones = tui.util.filter(this.wrapper.children, function(element) {\n            if (element.nodeType === 1) {\n                count += 1;\n                return true;\n            }\n        });\n        this.clones.count = count;\n    },\n\n    /**\n     * Set prev element - static elements\n     * @private\n     */\n    _setPrev: function() {\n        // clone\n        var i = 1,\n            clones = this.clones,\n            count = clones.count,\n            config = this._config,\n            width = config.width * count,\n            wrapper = this.wrapper;\n\n        if (!tui.util.isHTMLTag(wrapper.firstChild)) {\n            this.wrapper.removeChild(wrapper.firstChild);\n        }\n\n        for (; i &lt;= count; i++) {\n            wrapper.insertBefore(clones[count - i].cloneNode(true), wrapper.firstChild);\n        }\n\n        wrapper.style[config.dimension] = this._getWidth() + width + 'px';\n        wrapper.style[config.way] = this._getElementPos() - width + 'px';\n    },\n\n    /**\n     * Set next element - static elements\n     * @private\n     */\n    _setNext: function() {\n        var clones = this.clones,\n            count = clones.count,\n            config = this._config,\n            width = config.width * count,\n            wrapper = this.wrapper,\n            i = 0;\n        for (; i &lt; count; i++) {\n            wrapper.appendChild(clones[i].cloneNode(true));\n        }\n\n        wrapper.style[config.dimension] = this._getWidth() + width + 'px';\n    },\n\n    /**\n     * Expand wrapper's width | height\n     */\n    expandMovePanel: function() {\n        this.wrapper.style[this._config.dimension] = this._getWidth() + this._config.width + 'px';\n    },\n\n    /**\n     * Reduce wrapper's width | height\n     */\n    reduceMovePanel: function() {\n        this.wrapper.style[this._config.dimension] = this._getWidth() - this._config.width + 'px';\n    },\n\n    /*************\n     * flicking methods\n     *************/\n\n    /**\n     * Check whether flicking or not\n     * @param info\n     * @private\n     */\n    _isFlick: function(info) {\n        var evtList = {\n                list: [\n                    this.startPos,\n                    this.savePos\n                ]\n            },\n            result;\n\n        tui.util.extend(evtList, info);\n        result = this.movedetect.figure(evtList);\n        return result.isFlick;\n    },\n\n    /**\n     * Fix element pos, if flicking use magnetic\n     * @param {object} info information for fix element pos.\n     * @private\n     */\n    _fixInto: function(info) {\n        var isBackward = this._isBackward(),\n            isFlick = this._isFlick(info),\n            origin = this.startPos[this._config.way],\n            pos;\n\n        if (!isFlick || this._isEdge(info)) {\n            isBackward = !isBackward;\n            pos = this._getReturnPos(isBackward);\n            pos.recover = true;\n        } else {\n            pos = this._getCoverPos(isBackward, origin);\n        }\n\n        this._moveTo(pos, isBackward);\n    },\n\n    /**\n     * Move to pos\n     * @param {object} pos 이동 좌표\n     * @param {string} isBackward 역행인지 여부\n     * @private\n     */\n    _moveTo: function(pos, isBackward) {\n        var way = isBackward ? 'backward' : 'forward',\n            origin = this.startPos[this._config.way],\n            moved = this._getMoved(),\n            start = origin + moved;\n        pos.way = way;\n\n        this.mover.setDistance(pos.dist);\n        this.mover.action({\n            direction: way,\n            start: start,\n            complete: tui.util.bind(this._complete, this, pos, pos.cover)\n        });\n    },\n\n    /*************\n     * forth methods after effect end\n     *************/\n\n    /**\n     * Callback for move after, this method fire custom events\n     * @private\n     */\n    _complete: function(pos, customFire) {\n        if (customFire) {\n            /**\n             * @api\n             * @event Flicking#afterFlick\n             * @type {object}\n             * @property {number} dest - Destination value\n             * @property {number} dist - Distance value\n             * @property {boolean} cover\n             * @property {string} way - \"backward\", \"forward\"\n             * @example\n             * flick.on('afterFlick', function(data) {\n             *     console.log(data.way);\n             * });\n             */\n            this.fire('afterFlick', pos);\n        } else {\n            /**\n             * @api\n             * @event Flicking#returnFlick\n             * @type {object}\n             * @property {number} dest - Destination value\n             * @property {number} dist - Distance value\n             * @property {boolean} cover\n             * @property {boolean} recover\n             * @property {string} way - \"backward\", \"forward\"\n             * @example\n             * flick.on('returnFlick', function(data) {\n             *     console.log(data.way);\n             * });\n             */\n            this.fire('returnFlick', pos);\n        }\n\n        this.isLocked = false;\n        this.wrapper.style[this._config.way] = pos.dest + 'px';\n\n        if (!this.isFixedHTML) {\n            this._removePadding(pos);\n        } else {\n            if (this.isCircular) {\n                this._removeClones(pos);\n            }\n        }\n    },\n\n    /**\n     * Remove clones for static circular\n     * @private\n     */\n    _removeClones: function(pos) {\n        var removeCount = this.clones.count,\n            totalCount = removeCount * 2,\n            leftCount = removeCount,\n            rightCount,\n            config = this._config,\n            way = pos.recover ? 'none' : pos.way;\n\n        if (way === 'forward') {\n            leftCount = removeCount + 1;\n        } else if (way === 'backward') {\n            leftCount = removeCount - 1;\n        }\n        rightCount = totalCount - leftCount;\n\n        this._removeCloneElement(leftCount, 'firstChild');\n        this._removeCloneElement(rightCount, 'lastChild');\n        this.wrapper.style[config.dimension] = this._getWidth() - config.width * totalCount + 'px';\n        this.wrapper.style[config.way] = 0;\n    },\n\n    /**\n     * Remove clone elements\n     * @param {number} count clone element count\n     * @param {string} type key target node(firstChild|lastChild)\n     * @private\n     */\n    _removeCloneElement: function(count, type) {\n        var i = 0,\n            wrapper = this.wrapper;\n        for (; i &lt; count; i++) {\n            if (wrapper[type].nodeType !== 1) {\n                wrapper.removeChild(wrapper[type]);\n                i -= 1;\n                continue;\n            }\n            wrapper.removeChild(wrapper[type]);\n        }\n    },\n\n    /**\n     * Remove padding used for drag\n     * @param pos\n     * @private\n     */\n    _removePadding: function(pos) {\n        var children = this.wrapper.getElementsByTagName(this.itemTag),\n            pre = children[0],\n            forth = children[children.length -1],\n            config = this._config,\n            way = pos.recover ? 'none' : pos.way,\n            wrapper = this.wrapper;\n\n        if (way === 'forward') {\n            forth = children[1];\n        } else if (way === 'backward') {\n            pre = children[1];\n        }\n\n        wrapper.removeChild(pre);\n        wrapper.removeChild(forth);\n        wrapper.style[config.way] = 0 + 'px';\n        wrapper.style[config.dimension] = this._getWidth() - (config.width * 2) + 'px';\n    },\n\n    /*************\n     * utils for figure pos to move\n     *************/\n\n    /**\n     * Get return distance and destination\n     * @param {boolean} isBackward 역행여부\n     * @returns {{dest: *, dist: *}}\n     * @private\n     */\n    _getReturnPos: function(isBackward) {\n        var moved = this._getMoved();\n\n        return {\n            dest: this.startPos[this._config.way],\n            dist : isBackward ? moved : -moved,\n            cover: false\n        }\n    },\n\n    /**\n     * Get cover distance and destination\n     * @param {boolean} isBackward 역행 여부\n     * @param {number} origin 원래 이동 너비\n     * @returns {{dest: *, dist:*}}\n     * @private\n     */\n    _getCoverPos: function(isBackward, origin) {\n        var moved = this._getMoved(),\n            pos = { cover: true };\n\n        if (isBackward) {\n            pos.dist = -this._config.width + moved;\n            pos.dest = origin + this._config.width;\n        } else {\n            pos.dist = -this._config.width - moved;\n            pos.dest = origin - this._config.width;\n        }\n        return pos;\n    },\n\n    /**\n     * Get moved distance by drag\n     * @returns {number}\n     * @private\n     */\n    _getMoved: function() {\n        var from = (this.flow === 'horizontal') ? this.startPos.x : this.startPos.y,\n            to = (this.flow === 'horizontal') ? this.savePos.x : this.savePos.y,\n            moved = to - from;\n        return moved;\n    },\n\n    /**\n     * Check whether edge or not(but circular)\n     * @private\n     */\n    _isEdge: function() {\n        if (this.isCircular) {\n            return false;\n        }\n\n        var isNext = !this._isBackward(),\n            current = this._getElementPos(),\n            width = this._getWidth();\n\n        if (isNext &amp;&amp; (current &lt;= -width + this._config.width)) {\n            return true;\n        }\n\n        return (!isNext &amp;&amp; current > 0);\n    },\n\n    /**\n     * Get width wrapper\n     * @returns {Number}\n     * @private\n     */\n    _getWidth: function() {\n        return parseInt(this.wrapper.style[this._config.dimension], 10);\n    },\n\n    /**\n     * Get left px wrapper\n     * @returns {Number}\n     * @private\n     */\n    _getElementPos: function() {\n        return parseInt(this.wrapper.style[this._config.way], 10);\n    },\n\n    /**\n     * Get whether is back or forward\n     * @returns {boolean}\n     * @private\n     */\n    _isBackward: function() {\n        var direction = this.movedetect.getDirection([this.savePos, this.startPos]);\n        return direction === this._config.direction[0];\n    }\n});\n\ntui.util.CustomEvents.mixin(Flicking);\n\nmodule.exports = Flicking;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"